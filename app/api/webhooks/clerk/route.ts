// import { Webhook } from "svix"
// import { headers } from "next/headers"
// import { prisma } from "@/lib/db"
// import type { WebhookEvent } from "@clerk/nextjs/server"

// export async function POST(req: Request) {
//   const WEBHOOK_SECRET = process.env.CLERK_WEBHOOK_SECRET

//   if (!WEBHOOK_SECRET) {
//     console.error("CLERK_WEBHOOK_SECRET is not set")
//     return new Response("Webhook secret not configured", { status: 500 })
//   }

//   const headerPayload = await headers()
//   const svix_id = headerPayload.get("svix-id")
//   const svix_timestamp = headerPayload.get("svix-timestamp")
//   const svix_signature = headerPayload.get("svix-signature")

//   if (!svix_id || !svix_timestamp || !svix_signature) {
//     console.error("Missing svix headers")
//     return new Response("Error: missing svix headers", { status: 400 })
//   }

//   const body = await req.text()

//   const wh = new Webhook(WEBHOOK_SECRET)

//   let evt: WebhookEvent

//   try {
//     evt = wh.verify(body, {
//       "svix-id": svix_id,
//       "svix-timestamp": svix_timestamp,
//       "svix-signature": svix_signature,
//     }) as WebhookEvent
//   } catch (err) {
//     console.error("Error verifying webhook:", err)
//     return new Response("Webhook signature verification failed", { status: 400 })
//   }

//   const { type } = evt.data

//   try {
//     if (type === "user.created") {
//       const { id, email_addresses, first_name, last_name, image_url } = evt.data

//       const primaryEmail = email_addresses?.[0]?.email_address || ""

//       const user = await prisma.user.create({
//         data: {
//           clerkId: id,
//           email: primaryEmail,
//           firstName: first_name,
//           lastName: last_name,
//           avatar: image_url,
//           plan: "FREE",
//           credits: 10,
//         },
//       })

//       // Create default personal team
//       const team = await prisma.team.create({
//         data: {
//           name: `${first_name || "Personal"} Workspace`,
//           ownerId: user.id,
//         },
//       })

//       // Add ser as team owner
//       await prisma.teamMember.create({
//         data: {
//           teamId: team.id,
//           userId: user.id,
//           role: "OWNER",
//         },
//       })

//       await prisma.auditLog.create({
//         data: {
//           userId: user.id,
//           action: "USER_CREATED",
//           details: `New user registered: ${primaryEmail}`,
//         },
//       })
//     } else if (type === "user.updated") {
//       const { id, email_addresses, first_name, last_name, image_url } = evt.data

//       const primaryEmail = email_addresses?.[0]?.email_address || ""

//       const existingUser = await prisma.user.findUnique({
//         where: { clerkId: id },
//       })

//       await prisma.user.update({
//         where: { clerkId: id },
//         data: {
//           email: primaryEmail,
//           firstName: first_name,
//           lastName: last_name,
//           avatar: image_url,
//         },
//       })

//       if (
//         existingUser?.firstName !== first_name ||
//         existingUser?.lastName !== last_name ||
//         existingUser?.avatar !== image_url
//       ) {
//         await prisma.auditLog.create({
//           data: {
//             userId: existingUser?.id || id,
//             action: "USER_UPDATED",
//             details: `User profile updated`,
//             changes: {
//               firstName: first_name,
//               lastName: last_name,
//             },
//           },
//         })
//       }
//     } else if (type === "user.deleted") {
//       const { id } = evt.data

//       const user = await prisma.user.findUnique({
//         where: { clerkId: id },
//       })

//       if (user) {
//         await prisma.auditLog.create({
//           data: {
//             userId: user.id,
//             action: "USER_DELETED",
//             details: `User account deleted: ${user.email}`,
//           },
//         })
//       }

//       // Delete user (cascading will handle related records)
//       await prisma.user.delete({
//         where: { clerkId: id },
//       })
//     }
//   } catch (error) {
//     console.error("Webhook processing error:", error)
//     return new Response(JSON.stringify({ error: "Webhook processing failed" }), { status: 500 })
//   }

//   return new Response(JSON.stringify({ received: true }), { status: 200 })
// }

import { Webhook } from "svix"
import { headers } from "next/headers"
import { prisma } from "@/lib/db"
import type { WebhookEvent } from "@clerk/nextjs/server"

export async function POST(req: Request) {
  const WEBHOOK_SECRET = process.env.CLERK_WEBHOOK_SECRET

  if (!WEBHOOK_SECRET) {
    console.error("CLERK_WEBHOOK_SECRET is not set")
    return new Response("Webhook secret not configured", { status: 500 })
  }

  const headerPayload = await headers()
  const svix_id = headerPayload.get("svix-id")
  const svix_timestamp = headerPayload.get("svix-timestamp")
  const svix_signature = headerPayload.get("svix-signature")

  if (!svix_id || !svix_timestamp || !svix_signature) {
    console.error("Missing svix headers")
    return new Response("Error: missing svix headers", { status: 400 })
  }

  const body = await req.text()

  const wh = new Webhook(WEBHOOK_SECRET)

  let evt: WebhookEvent

  try {
    evt = wh.verify(body, {
      "svix-id": svix_id,
      "svix-timestamp": svix_timestamp,
      "svix-signature": svix_signature,
    }) as WebhookEvent
  } catch (err) {
    console.error("Error verifying webhook:", err)
    return new Response("Webhook signature verification failed", { status: 400 })
  }

  // Fix: Get type from evt, not evt.data
  const { type } = evt

  try {
    if (type === "user.created") {
      // Type narrowing - now TypeScript knows this is UserJSON
      const { id, email_addresses, first_name, last_name, image_url } = evt.data

      const primaryEmail = email_addresses?.[0]?.email_address || ""

      const user = await prisma.user.create({
        data: {
          clerkId: id,
          email: primaryEmail,
          firstName: first_name || null,
          lastName: last_name || null,
          avatar: image_url || null,
          plan: "FREE",
          credits: 10,
        },
      })

      // Create default personal team
      const team = await prisma.team.create({
        data: {
          name: `${first_name || "Personal"} Workspace`,
          ownerId: user.id,
        },
      })

      // Add user as team owner (fixed typo: "ser" -> "user")
      await prisma.teamMember.create({
        data: {
          teamId: team.id,
          userId: user.id,
          role: "OWNER",
        },
      })

      await prisma.auditLog.create({
        data: {
          userId: user.id,
          action: "USER_CREATED",
          details: `New user registered: ${primaryEmail}`,
        },
      })
    } else if (type === "user.updated") {
      const { id, email_addresses, first_name, last_name, image_url } = evt.data

      const primaryEmail = email_addresses?.[0]?.email_address || ""

      const existingUser = await prisma.user.findUnique({
        where: { clerkId: id },
      })

      if (!existingUser) {
        return new Response("User not found", { status: 404 })
      }

      await prisma.user.update({
        where: { clerkId: id },
        data: {
          email: primaryEmail,
          firstName: first_name || null,
          lastName: last_name || null,
          avatar: image_url || null,
        },
      })

      if (
        existingUser?.firstName !== first_name ||
        existingUser?.lastName !== last_name ||
        existingUser?.avatar !== image_url
      ) {
        await prisma.auditLog.create({
          data: {
            userId: existingUser.id,
            action: "USER_UPDATED",
            details: `User profile updated`,
            changes: {
              firstName: first_name || null,
              lastName: last_name || null,
            },
          },
        })
      }
    } else if (type === "user.deleted") {
      // For deleted events, only 'id' is available
      const { id } = evt.data

      const user = await prisma.user.findUnique({
        where: { clerkId: id || "" },
      })

      if (user) {
        await prisma.auditLog.create({
          data: {
            userId: user.id,
            action: "USER_DELETED",
            details: `User account deleted: ${user.email}`,
          },
        })

        // Delete user (cascading will handle related records)
        await prisma.user.delete({
          where: { clerkId: id || "" },
        })
      }
    }
  } catch (error) {
    console.error("Webhook processing error:", error)
    return new Response(JSON.stringify({ error: "Webhook processing failed" }), { status: 500 })
  }

  return new Response(JSON.stringify({ received: true }), { status: 200 })
}