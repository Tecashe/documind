// import { auth } from "@clerk/nextjs/server"
// import { prisma } from "@/lib/db"
// import { NextResponse } from "next/server"
// import PDFDocument from "pdfkit"

// export async function POST(req: Request, { params }: { params: { id: string } }) {
//   const { userId } = await auth()
//   if (!userId) return NextResponse.json({ error: "Unauthorized" }, { status: 401 })

//   try {
//     const document = await prisma.document.findUnique({
//       where: { id: params.id },
//       include: { user: true },
//     })

//     if (!document || document.user.clerkId !== userId) {
//       return NextResponse.json({ error: "Not found" }, { status: 404 })
//     }

//     if (!document.extractedText) {
//       return NextResponse.json({ error: "No extracted text available" }, { status: 400 })
//     }

//     const pdf = new PDFDocument()
//     const chunks: Buffer[] = []

//     pdf.on("data", (chunk) => chunks.push(chunk))

//     //Add metadata
//     pdf.metadata.Title = document.title
//     pdf.metadata.Author = document.user.name || "DocIntelligence"
//     pdf.metadata.CreationDate = new Date()

//     // Add content
//     pdf.fontSize(24).font("Helvetica-Bold").text(document.title, { margin: 30 })

//     pdf
//       .fontSize(10)
//       .font("Helvetica")
//       .text(`Classification: ${document.classification || "Unknown"}`, { margin: 10 })

//     if (document.confidence) {
//       pdf.text(`Confidence: ${(document.confidence * 100).toFixed(1)}%`)
//     }

//     pdf
//       .moveTo(30, pdf.y + 10)
//       .lineTo(550, pdf.y)
//       .stroke()

//     pdf.fontSize(12).font("Helvetica").text(document.extractedText, {
//       margin: 30,
//       align: "left",
//       width: 520,
//     })

//     // Add metadata footer
//     pdf.fontSize(8).text(`Generated by DocIntelligence on ${new Date().toLocaleString()}`, {
//       align: "center",
//       margin: 30,
//     })

//     pdf.end()

//     return new Promise((resolve) => {
//       pdf.on("end", () => {
//         const buffer = Buffer.concat(chunks)
//         resolve(
//           new NextResponse(buffer, {
//             headers: {
//               "Content-Type": "application/pdf",
//               "Content-Disposition": `attachment; filename="${document.title}.pdf"`,
//             },
//           }),
//         )
//       })
//     })
//   } catch (error) {
//     return NextResponse.json({ error: error instanceof Error ? error.message : "Export failed" }, { status: 500 })
//   }
// }


// import { auth } from "@clerk/nextjs/server"
// import { prisma } from "@/lib/db"
// import { NextResponse } from "next/server"
// import PDFDocument from "pdfkit"

// export async function POST(req: Request, { params }: { params: { id: string } }) {
//   const { userId } = await auth()
//   if (!userId) return NextResponse.json({ error: "Unauthorized" }, { status: 401 })

//   try {
//     const document = await prisma.document.findUnique({
//       where: { id: params.id },
//       include: { 
//         owner: true,
//         content: true,
//         classifications: true,
//       },
//     })

//     if (!document || document.owner.clerkId !== userId) {
//       return NextResponse.json({ error: "Not found" }, { status: 404 })
//     }

//     const extractedText = document.content?.rawText
//     if (!extractedText) {
//       return NextResponse.json({ error: "No extracted text available" }, { status: 400 })
//     }

//     const pdf = new PDFDocument()
//     const chunks: Buffer[] = []

//     pdf.on("data", (chunk: Buffer) => chunks.push(chunk))

//     //Add metadata
//     const ownerName = document.owner.firstName && document.owner.lastName 
//       ? `${document.owner.firstName} ${document.owner.lastName}` 
//       : document.owner.firstName || document.owner.lastName || "DocIntelligence"
    
//     pdf.info.Title = document.title
//     pdf.info.Author = ownerName
//     pdf.info.CreationDate = new Date()

//     // Add content
//     pdf.fontSize(24).font("Helvetica-Bold").text(document.title, { 
//       continued: false 
//     })
//     pdf.moveDown()

//     pdf
//       .fontSize(10)
//       .font("Helvetica")
//       .text(`Classification: ${document.documentType || "Unknown"}`)

//     if (document.classifications?.confidence) {
//       pdf.text(`Confidence: ${(document.classifications.confidence * 100).toFixed(1)}%`)
//     }

//     pdf.moveDown()
//     pdf
//       .moveTo(30, pdf.y)
//       .lineTo(550, pdf.y)
//       .stroke()
//     pdf.moveDown()

//     pdf.fontSize(12).font("Helvetica").text(extractedText, {
//       align: "left",
//       width: 520,
//     })

//     pdf.moveDown()
//     // Add metadata footer
//     pdf.fontSize(8).text(`Generated by DocIntelligence on ${new Date().toLocaleString()}`, {
//       align: "center",
//     })

//     pdf.end()

//     return new Promise<NextResponse>((resolve) => {
//       pdf.on("end", () => {
//         const buffer = Buffer.concat(chunks)
//         resolve(
//           new NextResponse(buffer as unknown as BodyInit, {
//             headers: {
//               "Content-Type": "application/pdf",
//               "Content-Disposition": `attachment; filename="${document.title}.pdf"`,
//             },
//           }),
//         )
//       })
//     })
//   } catch (error) {
//     return NextResponse.json({ error: error instanceof Error ? error.message : "Export failed" }, { status: 500 })
//   }
// }


import { auth } from "@clerk/nextjs/server"
import { prisma } from "@/lib/db"
import { NextResponse } from "next/server"
import PDFDocument from "pdfkit"

export async function POST(
  req: Request,
  context: { params: Promise<{ id: string }> }
) {
  const { id } = await context.params
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  try {
    const document = await prisma.document.findUnique({
      where: { id },
      include: {
        owner: true,
        content: true,
        classifications: true,
      },
    })

    if (!document || document.owner.clerkId !== userId) {
      return NextResponse.json({ error: "Not found" }, { status: 404 })
    }

    const extractedText = document.content?.rawText
    if (!extractedText) {
      return NextResponse.json(
        { error: "No extracted text available" },
        { status: 400 }
      )
    }

    const pdf = new PDFDocument()
    const chunks: Buffer[] = []

    pdf.on("data", (chunk: Buffer) => chunks.push(chunk))

    const ownerName =
      document.owner.firstName && document.owner.lastName
        ? `${document.owner.firstName} ${document.owner.lastName}`
        : document.owner.firstName || document.owner.lastName || "DocIntelligence"

    pdf.info.Title = document.title
    pdf.info.Author = ownerName
    pdf.info.CreationDate = new Date()

    pdf.fontSize(24).font("Helvetica-Bold").text(document.title, {
      continued: false,
    })
    pdf.moveDown()

    pdf
      .fontSize(10)
      .font("Helvetica")
      .text(`Classification: ${document.documentType || "Unknown"}`)

    if (document.classifications?.confidence) {
      pdf.text(`Confidence: ${(document.classifications.confidence * 100).toFixed(1)}%`)
    }

    pdf.moveDown()
    pdf.moveTo(30, pdf.y).lineTo(550, pdf.y).stroke()
    pdf.moveDown()

    pdf.fontSize(12).font("Helvetica").text(extractedText, {
      align: "left",
      width: 520,
    })

    pdf.moveDown()
    pdf.fontSize(8).text(`Generated by DocIntelligence on ${new Date().toLocaleString()}`, {
      align: "center",
    })

    pdf.end()

    return new Promise<NextResponse>((resolve) => {
      pdf.on("end", () => {
        const buffer = Buffer.concat(chunks)
        resolve(
          new NextResponse(buffer as unknown as BodyInit, {
            headers: {
              "Content-Type": "application/pdf",
              "Content-Disposition": `attachment; filename="${document.title}.pdf"`,
            },
          })
        )
      })
    })
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Export failed" },
      { status: 500 }
    )
  }
}